<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- fonts -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Open+Sans:wdth,wght@75,700&family=Roboto+Mono:ital,wght@0,400;0,700;1,400&family=Spectral:ital,wght@0,400;0,700;1,400&display=swap');
  </style>

  <title>Tobin Yehle | The Best Wordament Players Are Mind Bogglingly Good</title>
  <meta name="description" content="When I visit my family at Christmas boggle is always a popular choice of game,but a year ago the physical boggle board was often abandoned forwordament.Many ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://tobin.yehle.us/articles/boggle">
  <link rel="alternate" type="application/rss+xml" title="Tobin Yehle" href="http://tobin.yehle.us/feed.xml">

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?">

  
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <span class="header-title"><a class="site-title" href="/">
  <span class="site-title-brace">{</span>
  Tobin Yehle
  <span class="site-title-brace">}</span>
</a></span>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        

        
          
        
          
        
          
        
          
        
          
            
              <a class="page-link" href="/">About</a>
            
          
        
          
            
              <a class="page-link" href="/articles/">Articles</a>
            
          
        
          
            
              <a class="page-link" href="/projects">Projects</a>
            
          
        
          
            
              <a class="page-link" href="/pottery">Pottery</a>
            
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="page-header">
    <h1 class="post-title" itemprop="name headline">The Best Wordament Players Are Mind Bogglingly Good</h1>
    <p class="post-meta"><time datetime="2016-10-04T00:00:00+00:00" itemprop="datePublished">2016-10-04</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
  	<hr>
    <p>When I visit my family at Christmas boggle is always a popular choice of game,
but a year ago the physical boggle board was often abandoned for
<a href="https://www.microsoft.com/en-us/store/p/wordament/9wzdncrfhwfg">wordament</a>.
Many of my family members were quite good at the game (myself not among them),
but there were always a few players that seemed to find an impossible number of
words. We collectively speculated that they were cheating to save our egos, so I
wrote a simple solver to find every word on a Boggle board contained in a
dictionary. Source code for the project can be found
<a href="https://bitbucket.org/tobinyehle/bogglesolver">here</a>.</p>

<p>The short answer is, either they are not not cheating, or if they are they are
doing a very bad job of it. At least as of last Christmas. I havenâ€™t looked at
any scores since then.</p>

<h2 id="implementation">Implementation</h2>

<p>The approach I used is to build a trie of words in a dictionary file, and then
do an exhaustive depth first search of the board to find every valid word on the
board.</p>

<p>The trie is structured so every node has a flag saying if it is a valid word,
and a list of children.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">WordTree</span><span class="o">(</span><span class="n">children</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Char</span>, <span class="kt">WordTree</span><span class="o">],</span> <span class="k">val</span> <span class="nv">isWord</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>
</code></pre></div></div>

<p>With this representation, simultaneous recursion over the board and the trie
will find every word. The board is small enough that overflowing the stack
during the search will not be an issue.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">findAllWords</span><span class="o">(</span><span class="n">prevPath</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Location</span><span class="o">],</span> <span class="n">subDict</span><span class="k">:</span> <span class="kt">WordTree</span><span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">subwords</span> <span class="k">=</span> <span class="nf">pathStep</span><span class="o">(</span><span class="n">prevPath</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
    <span class="n">step</span> <span class="k">=&gt;</span>
      <span class="nv">subDict</span><span class="o">.</span><span class="py">subTree</span><span class="o">(</span><span class="nv">board</span><span class="o">.</span><span class="py">pieces</span><span class="o">(</span><span class="n">step</span><span class="o">))</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">subSubDict</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">findAllWords</span><span class="o">(</span><span class="n">prevPath</span> <span class="o">:+</span> <span class="n">step</span><span class="o">,</span> <span class="n">subSubDict</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="nv">thisLetter</span> <span class="k">=</span> <span class="nv">board</span><span class="o">.</span><span class="py">pieces</span><span class="o">(</span><span class="nv">prevPath</span><span class="o">.</span><span class="py">last</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">fixedSubwords</span> <span class="k">=</span> <span class="nv">subwords</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">word</span> <span class="k">=&gt;</span> <span class="n">thisLetter</span> <span class="o">+</span> <span class="n">word</span><span class="o">)</span>

  <span class="nf">if</span><span class="o">(</span><span class="nv">subDict</span><span class="o">.</span><span class="py">isWord</span><span class="o">)</span>
    <span class="n">thisLetter</span> <span class="o">+:</span> <span class="n">fixedSubwords</span>
  <span class="k">else</span>
    <span class="n">fixedSubwords</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">pathStep</code> is a function that returns all possible next steps in a valid
path, and <code class="language-plaintext highlighter-rouge">subTree</code> recurses down the dictionary trie. Everything at the end of
the function rebuilds words from the recursive calls to <code class="language-plaintext highlighter-rouge">findAllWords</code>.</p>

<h2 id="performance">Performance</h2>

<p>Solving a 5x5 board with a list of over 100 000 words took less than a second on
my laptop. Assuming this list could be fed directly to the game, there is no
reason an automated solver should ever miss any word. Apparently there are some
people who are just mind-bogglingly good at wordament.</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-wrapper">
      <a class="site-title" href="/">
  <span class="site-title-brace">{</span>
  Tobin Yehle
  <span class="site-title-brace">}</span>
</a>
      <br>
      <a class="footer-contact" href="mailto:tobin.yehle@gmail.com">tobin.yehle@gmail.com</a>
      <br>
       <a class="username" href="https://github.com/tyehle">
	<span class="icon icon--github"><svg viewBox="0 0 16 16">
    <g>
        <path d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
    </g>
</svg>
</span>
	tyehle
</a>
 
    </div>

  </div>

</footer>


  </body>

</html>
